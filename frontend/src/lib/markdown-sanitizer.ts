/**
 * Markdown Content Sanitizer
 * Provides XSS protection for markdown content by sanitizing HTML output
 *
 * Note: DOMPurify is not installed yet, so we provide a basic sanitizer
 * Install with: npm install dompurify
 * and @types/dompurify for TypeScript support
 */

/**
 * Basic HTML sanitizer without external dependencies
 * This provides defense-in-depth for XSS prevention
 * For production, use DOMPurify for comprehensive protection
 */
export const basicSanitizeHtml = (html: string): string => {
  // Create a temporary element to leverage browser's HTML parser
  const temp = document.createElement('div');
  temp.textContent = html;
  const sanitized = temp.innerHTML;

  return sanitized;
};

/**
 * Markdown-safe sanitizer that preserves markdown-friendly HTML
 * Allows safe markdown-generated HTML while removing dangerous content
 */
export const sanitizeMarkdownContent = (content: string): string => {
  if (!content) return '';

  // Create a temporary container
  const temp = document.createElement('div');
  temp.innerHTML = content;

  // List of allowed tags commonly generated by markdown processors
  const allowedTags = new Set([
    'P', 'BR', 'STRONG', 'B', 'EM', 'I', 'U', 'CODE', 'PRE',
    'H1', 'H2', 'H3', 'H4', 'H5', 'H6',
    'UL', 'OL', 'LI',
    'BLOCKQUOTE',
    'TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR', 'TD', 'TH',
    'A', 'IMG',
    'HR', 'DIV', 'SPAN'
  ]);

  // List of allowed attributes
  const allowedAttributes = new Set([
    'href', 'title', 'alt', 'src', 'width', 'height',
    'class', 'id', 'data-line', 'data-column'
  ]);

  // List of dangerous protocols
  const dangerousProtocols = new Set([
    'javascript:', 'data:', 'vbscript:', 'file:'
  ]);

  /**
   * Recursively clean elements
   */
  const cleanElement = (element: Element): void => {
    const tagName = element.tagName.toUpperCase();

    // Remove disallowed tags but keep their content
    if (!allowedTags.has(tagName)) {
      // Move children out and remove element
      while (element.firstChild) {
        element.parentNode?.insertBefore(element.firstChild, element);
      }
      element.parentNode?.removeChild(element);
      return;
    }

    // Clean attributes
    const attributesToRemove: string[] = [];
    if (element.attributes) {
      for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        const attrName = attr.name.toLowerCase();

        // Remove event handlers
        if (attrName.startsWith('on')) {
          attributesToRemove.push(attrName);
          continue;
        }

        // Check if attribute is allowed
        if (!allowedAttributes.has(attrName)) {
          attributesToRemove.push(attrName);
          continue;
        }

        // Check for dangerous protocols in href/src
        if ((attrName === 'href' || attrName === 'src') && attr.value) {
          const protocol = attr.value.split(':')[0].toLowerCase();
          if (dangerousProtocols.has(protocol + ':')) {
            attributesToRemove.push(attrName);
            continue;
          }

          // Only allow relative URLs and safe protocols for href
          if (attrName === 'href' && !attr.value.startsWith('#') && !attr.value.startsWith('/') && !attr.value.startsWith('http')) {
            attributesToRemove.push(attrName);
            continue;
          }
        }
      }
    }

    // Remove flagged attributes
    attributesToRemove.forEach(attr => {
      element.removeAttribute(attr);
    });

    // Recursively clean children
    const children = Array.from(element.children);
    children.forEach(child => cleanElement(child));
  };

  // Clean all elements in temp
  Array.from(temp.children).forEach(child => cleanElement(child));

  return temp.innerHTML;
};

/**
 * Sanitizer using DOMPurify if available
 * Falls back to basic sanitization if not installed
 */
export const sanitizeContent = async (content: string): Promise<string> => {
  try {
    // Try to use DOMPurify if available
    const { default: DOMPurify } = await import('dompurify');

    return DOMPurify.sanitize(content, {
      ALLOWED_TAGS: [
        'b', 'i', 'em', 'strong', 'a', 'p', 'br', 'code', 'pre',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'ul', 'ol', 'li', 'blockquote',
        'table', 'thead', 'tbody', 'tfoot', 'tr', 'td', 'th',
        'img', 'hr', 'div', 'span'
      ],
      ALLOWED_ATTR: ['href', 'title', 'target', 'rel', 'src', 'alt', 'width', 'height']
    });
  } catch {
    // DOMPurify not available, use basic sanitizer
    return sanitizeMarkdownContent(content);
  }
};

export const markdownSanitizer = {
  basicSanitizeHtml,
  sanitizeMarkdownContent,
  sanitizeContent
};
